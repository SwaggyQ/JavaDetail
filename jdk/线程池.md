# 线程池

![线程池的状态转换](1img/threadPoolStatus.jpg)

维护了一个值，前三位代表线程池状态，后29位代表线程数

```
	int c = ctl.get();
	// 如果线程数小于coorPoolSize，则addWorker
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
```


### coorPoolSize,如果线程数没到，则addWorker()
	如果线程池状态为shutdown，则添加失败
	如果线程数大于最大容量
	或者在添加core线程时候，线程大于了coorPoolSize
	不然就线程数+1，然后构建worker，然后启动线程，然后返回正确
	
	
	
	如果添加失败
	如果线程池停滞工作，则reject	
		或者用maxmin用于技计数
		
注意 ThreadFactory，RejectHandler，三个size大小

## execute方法
```
	int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
```
#### 先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的前三用于计算。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。
```
	private boolean addWorker(Runnable firstTask, boolean core) {
		retry:
		for (;;) {
		    int c = ctl.get();
		    // 得到线程池目前的状态
		    int rs = runStateOf(c);
		
		    // Check if queue empty only if necessary.
		    // 如果当前线程池状态是SHUTDOWN或者以上
		    // 除非是状态为SHUTDOWN，且新增的是非core，且队列不为空
		    // 否则应该直接添加失败
		    if (rs >= SHUTDOWN &&
		        ! (rs == SHUTDOWN &&
		           firstTask == null &&
		           ! workQueue.isEmpty()))
		        // 如果满足以上条件，则添加失败
		        return false;
		
		    for (;;) {
		    	// 再次得到目前的节点数
		        int wc = workerCountOf(c);
		        // 如果已经大于了最大数量，或者大于设定的参数
		        if (wc >= CAPACITY ||
		            wc >= (core ? corePoolSize : maximumPoolSize))
		            return false;
		        // 将线程数加一
		        if (compareAndIncrementWorkerCount(c))
		            break retry;
		        c = ctl.get();  // Re-read ctl
		        // 若线程状态已经改变，则需要执行外部的大循环，否则执行内部的循环
		        if (runStateOf(c) != rs)
		            continue retry;
		        // else CAS failed due to workerCount change; retry inner loop
		    }
		}
		...
	}

```
#### 以上的代码主要将线程池中的线程状态进行了更新，并将数目加一。再看到下面的代码
```
	// 标识是否启动成功
	boolean workerStarted = false;
	// 标识是否添加成功
    boolean workerAdded = false;
    Worker w = null;
    try {
    	// 构建worker，包换thread和runnable两个属性
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());
                // 如果目前状态是RUNNING，或者是SHUTDOWN但是添加的是非core
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
            	// 若添加成功，则启动对应的线程
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
```
#### 以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况
```
	private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
        	// 若之前已经在set中记录了worker，则需要移除
            if (w != null)
                workers.remove(w);
            // 永真循环的减小工作节点数
            decrementWorkerCount();
            tryTerminate();
        } finally {
            mainLock.unlock();
        }
    }
```
#### 大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看
```
	final void tryTerminate() {
	    for (;;) {
	        int c = ctl.get();
	        // 若状态还是RUNNING或者为 TIDYING或者TERMINATED
	        // 或者是SHUTDOWN但是任务队列不为空
	        // 则可以直接退出当前方法
	        if (isRunning(c) ||
	            runStateAtLeast(c, TIDYING) ||
	            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
	            return;
	        if (workerCountOf(c) != 0) { // Eligible to terminate
	            interruptIdleWorkers(ONLY_ONE);
	            return;
	        }
	
	        final ReentrantLock mainLock = this.mainLock;
	        mainLock.lock();
	        try {
	            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
	                try {
	                    terminated();
	                } finally {
	                    ctl.set(ctlOf(TERMINATED, 0));
	                    termination.signalAll();
	                }
	                return;
	            }
	        } finally {
	            mainLock.unlock();
	        }
	        // else retry on failed CAS
	    }
	}
```


#### 再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑
```
	// 如果此时线程池的运行状态是正常的，但是上一步添加worker失败。则需要将传入的Runnable参数放入阻塞队列中
	if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 再重复检查一遍，若线程池不在运行，则需要移除任务，并用拒绝策略执行相应的方法
        if (! isRunning(recheck) && remove(command))
            reject(command);
        // 如果此时的工作节点数为0，则需要直接新节点
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
```







#### 以上详解了在java中对于ThreadPool的各个方法属性的作用。现在我们看一下在java中自带的几种线程池类型都是怎么通过这几个参数起作用的。

### FixedThreadPool
```
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

### SingleThreadExecutor
```
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```

### CachedThreadPool
```
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```
### ScheduledThreadPoolExecutor
```
    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
```



## 参考
[线程池五种状态转化的解释](https://www.cnblogs.com/-wyl/p/9760670.html)