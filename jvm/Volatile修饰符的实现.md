---
title: Volatile修饰符的实现
date: 2019-03-08 15:39:25
tags: jdk
---

## 前言
#### 本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。
## 正文
#### 开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。
#### 探究这个原因，用最简单的一句话去解释一下就是:为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。
#### 因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1,L2,L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。

![# 三级缓存](/Users/sugu/Desktop/cache.png)

- 缓存大大缩小了高速CPU与低速内存之间的差距。以三层缓存架构为例：
- L1 Cache最接近CPU, 容量最小（如32K、64K等）、速度最高，每个核上都有一个L1 Cache。
- L2 Cache容量更大（如256K）、速度更低, 一般情况下，每个核上都有一个独立的L2 Cache。
- L3 Cache最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。

#### 从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。
#### 最简单的例子就是
```
	i=i+1
```
#### 假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2.但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1.
#### 对于这个问题，有两种方式可以解决
- 总线加锁
	对内存总线进行加锁，例如当线程1从共享区域中取了x变量之后，对总线进行加锁。即所有线程此时都不能再访问共享变量，只有线程1对x变量处理之后，写回共享内存之后然后解锁之后，其他线程才能继续记性解锁。
- 缓存一致性协议，MESI协议
	MESI是intel公司提出的一种缓存一致性协议，即对缓存中的变量分配4中不同的状态
	
		- M: modify， 即当前cpu对应的缓存的变量在其他核中已被修改
		- E: exclusive， 即变量只在当前核中被缓存过
		- S: shared， 即当前缓存的变量在其他cpu中也被缓存过
		- I: invalid， 缓存的变量已失效

#### 第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况

#### 讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题
- 原子性:
	一个操作必须要么全部完成，要么不完成。不会出现完成一半的情况
- 可见性:
	在一个线程中做的修改，能立刻被其他线程感知
- 重排序:
	当我们写程序的时候，几行代码不一定都按照我们写的顺序执行。编译器可能会对代码进行看似乱序的执行顺序。但是这个乱序必须保证和单线程执行结果一样。下面用个例子解释一下
	
	```
		int i = 0;              //语句1  
		boolean flag = false;	//语句2  
		i = 1;                //语句3  
		flag = true;          //语句4
	```
	上面的代码不一定完全按照1-2-3-4这样的顺序执行，可能会是2-1-4-3。这就是重排序。但是3永远不会在1之前执行，同理4不会在2之前执行。这就是保证有关联的语句之间的顺序不会被打破，保证若是单线程执行条件下，结果都会一样。但是多线程情况就会出现问题
	
### 我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。
### Volatile
##### 好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质
- 被Volatile修饰的变量都会保证强可见性
- 被Volatile修饰的变量都会禁止重排序

#### 以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用

### 可见性
#### 由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性
### 重排序
#### Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子
```
//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```

#### 这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的

### 原子性
#### Volatile修饰的变量其实是不保证原子性的。同样看个例子
```
public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
         
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
```
