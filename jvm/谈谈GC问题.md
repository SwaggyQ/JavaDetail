# 谈谈GC问题
## 前文
#### 上一章中，我们已经看了JVM中的内存分布。也提到了堆是GC发生的主要位置，方法区也会存在GC的可能性，但是回收效率很低。那么本章我们要看看到底GC的时候，虚拟机中发生了什么事。
## 正文
#### 开始讲GC之前，我想先说说。GC到底是什么？GC就是Garbage Collect的意思，就是定期回收在内存中已经再也不会被用到的内存块，可以再分配给其他对象使用的过程。从我上一句对粗略的GC的定义中，可以发现有几个重要的概念
- 怎么判断哪些内存块是不会再被用到的
- 什么时候去回收这部分内存
- 怎么回收呢
#### 好的，带着这几个问题，我们正式去了解一下GC。

## 怎么判断内存是否该回收
#### 首先我们看到第一个问题。在我们平时编码的过程中，会经常的去new一个个对象，这样就会在堆中划分一块块内存供各个对象使用。那么我们怎么去判断哪些对象是之后再也用不到的呢？

### 引用计数法
#### 这是一种很容易想到的策略方法。就是用一个计数器，计算着每个对象是不是有被调用的地方，有一个调用，计数器+1，调用失效后就计数器-1.这样，每个计数器指数为0的对象都是再也不会用到的。这个方法非常直观，的确也有很多程序语言是使用这种方式来判断无效的对象，例如python。但是这个方法有一个很致命的缺点就是他无法回收相互引用的两个对象。因为这个缺陷，所以java并没有采取这种方式
#TODO 相互引用
### 可达性分析
#### 这种方式是java目前采取的
# TODO 可达性图
#### 从图中可以看到，java采用的这个方法需要先确定一些GC ROOT的变量，用这些作为起点去分析可以引用到对象，这些引用组成了引用链，不可以被引用链到达的对象就是被标记为不可达的。讲到引用这边提一句引用的几种分类
- 强引用 
	类似
	```a = b```
	这种赋值语句带来的引用叫做强引用。这是最高等级的引用方式，只要对象存在这种强引用，就不会被GC回收
	
- 软引用
	仅次于强引用的引用类型。 
	```SoftReference<String> sr = new SoftReference<String>(new String("hello"));```
	存在软引用的对象在堆内存第一次满引发的GC时不会被回收。但是若第一次GC后，堆内内存仍过大，就会进行第二次GC，将存在软引用的对象也进行回收。

- 弱引用
	比软引用更弱等级的引用类型
	```WeakReference<String> sr = new WeakReference<String>(new String("hello"));```
	弱引用在GC时都会被回收，并不想软引用那样有存活一次的机会
	
- 虚引用